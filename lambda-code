mport boto3
import json
import logging
import os

from botocore.exceptions import ClientError

hosted_zone_id = os.environ.get("HOSTED_ZONE_ID")
hosted_zone_name = os.environ.get("HOSTED_ZONE_NAME")
queue_name = os.environ.get("QUEUE_NAME")

logger = logging.getLogger()
logger.setLevel(logging.INFO)


def lambda_handler(event, context):
    """
    Receive event from SQS, triggers lambda. Ignore trigger event,
    go to queue and pull message.
    Parse message, for ReceiptHandle, EC2InstanceId.
    Set common boto3.clients, pass to subfunctions.


    Inputs: Event from SNS queue

    Outputs: logger

    Returns: None
    """
    logger.info(event)  # {"test-autoscale": "sent-to-sqs"}
    try:
        sqs = boto3.client("sqs")
        ec2 = boto3.client("ec2")
    except ClientError as e:
        logger.critical("ClientError-->: {}".format(e))

    queue_url, receipt_handle, instance_id = get_message_from_queue(sqs, queue_name)

    while instance_id:
        ip = allocation_avalable_associate(ec2, instance_id)
        logger.info("Attempting to allocate this-->: {}".format(ip))

        if ip is not None:
            logger.info("Existing eip allocation for-->: {}".format(ip))
            create_dns_record(hosted_zone_name, hosted_zone_id, ip)
            delete_message_from_queue(sqs, queue_url, receipt_handle)
            instance_id = False
        else:
            allocate_eip(ec2)
            break


def get_message_from_queue(sqs_client, queue_name):
    """
    Using SQS client, pull message from target queue.
    Parse for ReceiptHandle and Body.  Get EC2InstanceId from body.
    Do a quick sanity check of the event for key errors.
    A bit silly but check for client errors as well.

    Inputs: sqs_client, queue_name

    Outputs: to logger

    Returns: tuple(QueueUrl, EC2InstanceID, ReceiptHandle)
    """
    logger.info(queue_name)

    target_queue = sqs_client.get_queue_url(QueueName=queue_name)
    queue_url = target_queue["QueueUrl"]

    response = sqs_client.receive_message(
        QueueUrl=queue_url,
        AttributeNames=["All"],
        MessageAttributeNames=["All"],
        MaxNumberOfMessages=1,
    )

    try:
        response["Messages"]
    except KeyError as e:
        logger.info("No messages on queue-->: {}".format(e))
        return (queue_url, False, False)

    receipt_handle = response["Messages"][0]["ReceiptHandle"]
    json_body = json.loads(response["Messages"][0]["Body"])
    instance_id = json_body["detail"]["EC2InstanceId"]

    logger.info("Found this message in the queue-->: {}".format(response))
    logger.info("RecepitHandle-->: {}".format(receipt_handle))
    logger.info("body-->: {}".format(json_body))
    logger.info("EC2InstanceId-->: {}".format(instance_id))

    return (queue_url, receipt_handle, instance_id)


def delete_message_from_queue(sqs_client, queue_url, receipt_handle):
    """
    Delete the message from the queue.

    Inputs: sqs_client, queue_url, receipt_handle Ignore event provided,
    go to queue and pull message.

    Outputs: to logger

    Returns: None
    """
    delete_queue_message = sqs_client.delete_message(
        QueueUrl=queue_url, ReceiptHandle=receipt_handle
    )
    logger.info("delete_queue_message-->: {}".format(delete_queue_message))


def allocation_avalable_associate(ec2_client, instance_id):
    """
    Find unallocated elastic IP, associate that IP to an InstanceId

    Inputs: boto3.client, InstanceId

    Outputs: log info

    Returns: PublicIP address of associated InstanceId, if not returns None
    """

    logger.info("Trying to allocate instance_id-->: {}".format(instance_id))
    filters = [{"Name": "domain", "Values": ["vpc"]}]
    addresses_dict = ec2_client.describe_addresses(Filters=filters)
    logger.info("address_dict-->: {}".format(addresses_dict))
    for eip in addresses_dict["Addresses"]:
        if "AssociationId" not in eip:
            logger.info("Available PublicIp-->: {}".format(eip["PublicIp"]))
            association_eip = ec2_client.associate_address(
                InstanceId=instance_id, PublicIp=eip["PublicIp"]
            )
            logger.info("association_eip-->: {}".format(association_eip))
            return eip["PublicIp"]

    return None


def create_dns_record(zone_name, zone_id, ip):
    """
    Set boto3.client for route53.
    Write a route53 dns record to a zone using supplied ip.

    Inputs: zone_name, zone_id, IP address

    Outputs: log info

    Returns: None
    """
    try:
        route53_client = boto3.client("route53")
    except ClientError as e:
        logger.critical("ClientError: {}".format(e))
    logger.info("Creating DNS record for this ip-->: {}".format(ip))
    public_dns = ip.replace(".", "-") + "." + zone_name
    logger.info("public_dns-->: {}".format(public_dns))
    record_set = route53_client.change_resource_record_sets(
        HostedZoneId=zone_id,
        ChangeBatch={
            "Comment": "Add new instance to Route53",
            "Changes": [
                {
                    "Action": "UPSERT",
                    "ResourceRecordSet": {
                        "Name": public_dns,
                        "Type": "A",
                        "TTL": 3600,
                        "ResourceRecords": [{"Value": ip}],
                    },
                }
            ],
        },
    )
    logger.info("Writing DNS Record-->: {}".format(record_set))


def allocate_eip(ec2_client):
    """
    Allocate an elastic ip from from client public pool(s)
    or from aws pool if available pool addresses count is 0.

    Inputs: boto3.client

    Outputs: log info

    Returns: None
    """
    response = ec2_client.describe_public_ipv4_pools()
    logger.info("Public Pools available-->: {}".format(response))
    for pool in response["PublicIpv4Pools"]:
        ids = [pool["PoolId"]]
    for id in ids:
        if pool["TotalAvailableAddressCount"] != 0:
            allocate_own_address = ec2_client.allocate_address(
                Domain="vpc", PublicIpv4Pool=id
            )
            logger.info("Allocating from pool-->: {}".format(allocate_own_address))
        else:
            allocate_aws_address = ec2_client.allocate_address(Domain="vpc")
            logger.warning("Allocating from aws-->: {}".format(allocate_aws_address))
